;;; -*- :mode: lisp; package: ("XML-PARSER")
#|
<DOCUMENTATION>
<DESCRIPTION>
the "document" container for xml data streams
</DESCRIPTION>
<CHRONOLOGY>
<DATE>19971210</DATE>
 <DELTA>validation is now specified distinct from whether the external dtd is necssary.
  the document enforces it based <CODE>XML-DOCUMENT.VALIDATE?</CODE> which defaults to
  the value of *xml-validate?* at the time the document was created.
  </DELTA>
 <DATE>19980223</DATE>
  <DELTA>patched xml-node.append-element for comments</DELTA>
</CHRONOLOGY>
</DOCUMENTATION>
|#

(in-package :xml-parser)

#|
document    ::= prolog element Misc*
prolog      ::= XMLDecl? Misc* (doctypedecl Misc*)?
XMLDecl     ::= '<?XML' VersionInfo EncodingDecl? standalone? S? '?>'
VersionInfo ::= S 'version' Eq ('"1.0"' | "'1.0'")
Misc        ::= Comment | PI | S
|#
 
(defMethod read-xml-stream
           ((stream stream) &key (validate  *xml-validate?*))
  (read-xml-stream (markup-stream stream) :validate validate))

(defMethod read-xml-stream
           ((*markup-stream* concatenated-stream)
            &key ((:validate *xml-validate?*) *xml-validate?*))
  (let* ((*document* (make-instance (node-class 'xml-document nil *markup-stream*)
                       :url *markup-stream*))
         (*dtd* *dtd*)
         (*parent-node* *document*)
         (*readtable* *markup-pcdata-readtable*)
         (*package* (markup-package *markup-stream*))
         (*xml-preserve-whitespace* t)
         (eof '#.(gensym)))
    (unless (peek-char *tag-open-char* *markup-stream* nil)
      (xml-form-error *markup-stream* "document contains no elements."))

    ;; handler-bind since i want the dynamic context
    (handler-bind ;; handle errors other than file errors
      ((stream-error #'(lambda (condition) condition))
       (error #'(lambda (condition)
                  (warn "error while reading from ~s:~%~a"
                        (parse-position *markup-stream*) condition)
                  (if *xml-handle-errors* (return-from read-xml-stream nil)))))
      (loop (when (eq eof (read-process-pcdata *markup-stream* nil nil eof))
              (return))))

    (cond ((null *dtd*)
           (xml-validity-error *markup-stream* "no dtd."))
          ((not (typep *dtd* *document-type-definition-class*))
           (xml-cell-error *document* "illegitimate dtd: ~s." *dtd*))
          ((null (xml-document.element *document*))
           (xml-validity-error *document* "no root element present."))
        #|19971210: this constraint is not correct: a given dtd should permit
            various root elements. or none.
          ((not (eq (xml-node.name (dtd.root *dtd*)) (xml-node.name root)))
           (break)
           (xml-validity-error *document*
                               "illegitimate root element: ~s." root)) |#
          )
    *document*))

(defMethod read-xml-stream
           ((source pathname) &key (validate  *xml-validate?*))
  (with-open-file (stream source :direction :input)
    (read-xml-stream stream :validate validate)))

(defMethod read-xml-stream
           ((source string) &key (validate  *xml-validate?*))
  (with-input-from-string (stream source)
    (read-xml-stream stream :validate validate)))

(defMethod load-xml
           ((source t) &key (validate  *xml-validate?*))
  (let ((document (read-xml-stream source :validate validate)))
        (when (typep document 'xml-document)
          (xml-document.element document))))

#|
 the parsing perse involves binding the dtd and the root element.
 they are the only elements which matter. everything ewlse is ignored
 |#

(defMethod xml-node.append-element
           ((parent xml-document) (child xml-element))
  (when (xml-document.element parent)
    (xml-validity-error parent "multiple elements: ~s" child))
  (setf (xml-document.element parent) child)
  child)

(defMethod xml-node.append-element
           ((parent xml-document) (child t))
  (typecase child
    (xml-comment (call-next-method))
    (t (warn "illegitimate content in xml document: ~s." child)
       nil)))

(defMethod xml-node.append-element
           ((parent xml-document) (child xml-text))
  ;; ignore strings outside of the root element
  nil)

(defMethod xml-node.append-element
           ((parent xml-document) (child string))
  ;; ignore strings outside of the root element
  nil)


(defMethod xml-node.append-element
           ((parent xml-document) (child dtd))
  "in the process of reading a documentation type declaration from a stream,
    a dtd element has been generated by a <!DOCTYPE ...> element.
    if the document is a dtd-document, the succeeding
    elements will be assimilated into its contents as they are read/processed.
    for both xml- and dtd-documents, the reader package is modified so that
    tags are, by default, interned in a package specific to the dtd."
  (when (xml-document.dtd parent)
    (xml-validity-error parent "multiple dtd's: ~s" child))
  (setf (xml-document.dtd parent) child)
  child)

(defMethod xml-node.append-element
           ((parent xml-document) (child doctype))
  ;; when a doctype form is specified for a document, it passes through here.
  ;; then if the document is not standalone, then retrieve the document definition
  ;; otherwise, look to see if the dtd already exists.
  ;; if there is an internal dtd, generate a copy of the external dtd or if no external
  ;; dtd exists, a copy of a temporary internal dtd.
  ;; the copy is necessary in order to augment freely
  (setf (xml-node.parent child) parent)
  (setf (xml-document.doctype parent) child)
  (if (or (eq :no (xml-document.standalone? parent))
          (and (null (xml-document.standalone? parent))
               (or (xml-node.system child) (xml-node.public-id child))))
    (if (setf *dtd*
              (or (dtd (doctype.name child))
                  (and (xml-node.public-id child)
                       (load-dtd (doctype.name child) (xml-node.public-id child)))
                  (and (xml-node.system child)
                       (load-dtd (doctype.name child) (xml-node.system child)))))
      (setf (xml-document.dtd parent) *dtd*)
      (xml-validity-error parent "cannot load dtd: ~@[~a] ~@[~a]."
                          (xml-node.public-id child) (xml-node.system child)))
    (if (setf *dtd* (dtd (string (doctype.name child))))
      (setf (xml-document.dtd parent) *dtd*)))
  ;; if either the document requires the external document definition or there are
  ;; internal declarations present, then either load the specified dtd or
  ;; ensure that there is a temporary version.
  (when (doctype.internal child)
    (cond ((typep *dtd* 'dtd)
           (setf *dtd* (copy-instance *dtd*))
           (setf (dtd.url *dtd*)
                 (string (gentemp (namestring (dtd.url *dtd*))))))
          (t
           (setf *dtd*
                 (copy-instance
                  (make-instance (node-class 'document-type-definition
                                             'xml::doctype parent)
                    :name (doctype.name child)
                    :url (format nil "internal:~a" (doctype.url child)))))))

    (setf (xml-document.dtd parent) *dtd*)
    (let ((*parent-node* *dtd*))
      (process-markup-element (doctype.internal child) parent)))
  child)
;(setf (dtd t) nil)

:EOF
